{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }



	"array wali": {
  "prefix": "arr",
  "body": [
    "#include <bits/stdc++.h>",
    "using namespace std;",
    "#define nl '\\n'",
    "#define IO                            \\",
    "    ios_base::sync_with_stdio(false); \\",
    "    cin.tie(NULL);",
    "typedef long long ll;",
    "const long long mod = 1e9 + 7;",
    "",
    "signed main()",
    "{",
    "    IO;",
    "    ll t = 1;",
    "    cin >> t;",
    "    for (ll z = 0; z < t; z++)",
    "    {",
    "        ll n;",
    "        cin>>n;",
    "        vector<ll> arr(n);",
    "        for (int i = 0; i < n; i++)",
    "        {",
    "            cin >> arr[i];",
    "        }",
	"$0",
    "    }",
    "}"
  ],
  "description": ""
},
"simple ": {
  "prefix": "basic",
  "body": [
    "#include <bits/stdc++.h>",
    "using namespace std;",
    "#define nl '\\n'",
    "#define IO                            \\",
    "    ios_base::sync_with_stdio(false); \\",
    "    cin.tie(NULL);",
    "typedef long long ll;",
    "const long long mod = 1e9 + 7;",
    "",
    "signed main()",
    "{",
    "    IO;",
    "    ll t = 1;",
    "    cin >> t;",
    "    for (ll z = 0; z < t; z++)",
    "    {",
    "        ll n;",
    "        cin>>n;",
	"$0",
    "    }",
    "}"
  ],
  "description": ""
},
"binary expo": {
  "prefix": "power",
  "body": [
    "ll pow(ll a, ll b, ll mod = mod)",
    "{",
    "    a %= mod;",
    "    ll res = 1;",
    "    while (b > 0)",
    "    {",
    "        if (b & 1)",
    "            res = (res * a) % mod;",
    "        a = (a * a) % mod;",
    "        b >>= 1;",
    "    }",
    "    return res;",
    "}"
  ],
  "description": ""
},
"DSU": {
  "prefix": "DSU",
  "body": [
    "class DSU",
    "{",
    "public:",
    "    vector<ll> par, size;",
    "    DSU(ll n)",
    "    {",
    "        par.resize(n + 1);",
    "        size.resize(n + 1);",
    "        for (ll i = 0; i <= n; i++)",
    "        {",
    "            par[i] = i;",
    "            size[i] = 1;",
    "        }",
    "    }",
    "",
    "    ll fin(ll node)",
    "    {",
    "        if (node == par[node])",
    "            return node;",
    "        return par[node] = fin(par[node]);",
    "    }",
    "",
    "    void uni(ll u, ll v)",
    "    {",
    "        ll par_u = fin(u);",
    "        ll par_v = fin(v);",
    "        if (par_u == par_v)",
    "            return;",
    "        if (size[par_u] < size[par_v])",
    "        {",
    "            par[par_u] = par_v;",
    "            size[par_v] += size[par_u];",
    "        }",
    "        else",
    "        {",
    "            par[par_v] = par_u;",
    "            size[par_u] += size[par_v];",
    "        }",
    "    }",
    "};"
  ],
  "description": ""
},
"SegmentTree": {
  "prefix": "SegmentTree",
  "body": [
    "",
    "",
    "//Adnan Ahmads template of  segment tree (cf handle:adnanahmad)",
    "/*",
    "===============================",
    "     SEGMENT TREE TEMPLATE",
    "===============================",
    "1. Create the segment tree:",
    "   SegmentTree<ll> st(n, mergeFn, neutralValue);",
    "",
    "2. Build from input vector:",
    "   st.build(a);",
    "",
    "3. Query from l to r (inclusive):",
    "   st.query(l, r);",
    "",
    "4. Update a single position:",
    "   st.update(index, newValue);",
    "",
    "--------------------------------",
    "COMMON MERGE FUNCTIONS:",
    "",
    "• SUM      → [](ll a, ll b) { return a + b; }, 0LL",
    "• MIN      → [](ll a, ll b) { return min(a, b); }, LLONG_MAX",
    "• MAX      → [](ll a, ll b) { return max(a, b); }, LLONG_MIN",
    "• GCD      → [](ll a, ll b) { return __gcd(a, b); }, 0LL",
    "• XOR      → [](ll a, ll b) { return a ^ b; }, 0LL",
    "",
    "===============================",
    "*/",
    "",
    "template <typename T>",
    "struct SegmentTree",
    "{",
    "    ll n;",
    "    vector<T> tree;",
    "    function<T(T, T)> merge;",
    "    T NEUTRAL;",
    "",
    "    SegmentTree(ll size, function<T(T, T)> mergeFn, T neutral)",
    "    {",
    "        n = size;",
    "        merge = mergeFn;",
    "        NEUTRAL = neutral;",
    "        tree.assign(4 * n, NEUTRAL);",
    "    }",
    "",
    "    void build(const vector<T> &a, ll v, ll tl, ll tr)",
    "    {",
    "        if (tl == tr)",
    "        {",
    "            tree[v] = a[tl];",
    "        }",
    "        else",
    "        {",
    "            ll tm = (tl + tr) / 2;",
    "            build(a, v * 2, tl, tm);",
    "            build(a, v * 2 + 1, tm + 1, tr);",
    "            tree[v] = merge(tree[v * 2], tree[v * 2 + 1]);",
    "        }",
    "    }",
    "",
    "    void build(const vector<T> &a)",
    "    {",
    "        build(a, 1, 0, n - 1);",
    "    }",
    "",
    "    T query(ll v, ll tl, ll tr, ll l, ll r)",
    "    {",
    "        if (l > r)",
    "            return NEUTRAL;",
    "        if (l == tl && r == tr)",
    "            return tree[v];",
    "        ll tm = (tl + tr) / 2;",
    "        return merge(",
    "            query(v * 2, tl, tm, l, min(r, tm)),",
    "            query(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r));",
    "    }",
    "",
    "    T query(ll l, ll r)",
    "    {",
    "        return query(1, 0, n - 1, l, r);",
    "    }",
    "",
    "    void update(ll v, ll tl, ll tr, ll pos, T new_val)",
    "    {",
    "        if (tl == tr)",
    "        {",
    "            tree[v] = new_val;",
    "        }",
    "        else",
    "        {",
    "            ll tm = (tl + tr) / 2;",
    "            if (pos <= tm)",
    "                update(v * 2, tl, tm, pos, new_val);",
    "            else",
    "                update(v * 2 + 1, tm + 1, tr, pos, new_val);",
    "            tree[v] = merge(tree[v * 2], tree[v * 2 + 1]);",
    "        }",
    "    }",
    "",
    "    void update(ll pos, T new_val)",
    "    {",
    "        update(1, 0, n - 1, pos, new_val);",
    "    }",
    "};",
    ""
  ],
  "description": "yeeah sement tree bruuh"
}
}
