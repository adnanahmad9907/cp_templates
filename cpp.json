{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }



	"array wali": {
  "prefix": "arr",
  "body": [
    "// Created by Adnan Ahmad",
    "// Created on ${CURRENT_YEAR}-${CURRENT_MONTH}-${CURRENT_DATE} ",
    "",
    "#include <bits/stdc++.h>",
    "using namespace std;",
    "#define nl '\\n'",
    "#define IO                            \\",
    "    ios_base::sync_with_stdio(false); \\",
    "    cin.tie(NULL);",
    "typedef long long ll;",
    "const long long mod = 1e9 + 7;",
    "",
    "signed main()",
    "{",
    "    IO;",
    "    ll t = 1;",
    "    cin >> t;",
    "    for (ll z = 0; z < t; z++)",
    "    {",
    "        ll n;",
    "        cin>>n;",
    "        vector<ll> arr(n);",
    "        for (int i = 0; i < n; i++)",
    "        {",
    "            cin >> arr[i];",
    "        }",
	"$0",
    "    }",
    "}"
  ],
  "description": ""
},
"simple ": {
  "prefix": "zainab",
  "body": [
    "// Created by Adnan Ahmad",
    "// Created on ${CURRENT_YEAR}-${CURRENT_MONTH}-${CURRENT_DATE} ",
    "",
    "#include <bits/stdc++.h>",
    "using namespace std;",
    "#define nl '\\n'",
    "#define IO                            \\",
    "    ios_base::sync_with_stdio(false); \\",
    "    cin.tie(NULL);",
    "typedef long long ll;",
    "const long long mod = 1e9 + 7;",
    "",
    "signed main()",
    "{",
    "    IO;",
    "    ll t = 1;",
    "    cin >> t;",
    "    for (ll z = 0; z < t; z++)",
    "    {",
    "        ll n;",
    "        cin>>n;",
	"$0",
    "    }",
    "}"
  ],
  "description": ""
},
"binary expo": {
  "prefix": "power",
  "body": [
    "ll pow(ll a, ll b, ll mod = mod)",
    "{",
    "    a %= mod;",
    "    ll res = 1;",
    "    while (b > 0)",
    "    {",
    "        if (b & 1)",
    "            res = (res * a) % mod;",
    "        a = (a * a) % mod;",
    "        b >>= 1;",
    "    }",
    "    return res;",
    "}"
  ],
  "description": ""
},
"DSU": {
  "prefix": "DSU",
  "body": [
    "class DSU",
    "{",
    "public:",
    "    vector<ll> par, size;",
    "    DSU(ll n)",
    "    {",
    "        par.resize(n + 1);",
    "        size.resize(n + 1);",
    "        for (ll i = 0; i <= n; i++)",
    "        {",
    "            par[i] = i;",
    "            size[i] = 1;",
    "        }",
    "    }",
    "",
    "    ll fin(ll node)",
    "    {",
    "        if (node == par[node])",
    "            return node;",
    "        return par[node] = fin(par[node]);",
    "    }",
    "",
    "    void uni(ll u, ll v)",
    "    {",
    "        ll par_u = fin(u);",
    "        ll par_v = fin(v);",
    "        if (par_u == par_v)",
    "            return;",
    "        if (size[par_u] < size[par_v])",
    "        {",
    "            par[par_u] = par_v;",
    "            size[par_v] += size[par_u];",
    "        }",
    "        else",
    "        {",
    "            par[par_v] = par_u;",
    "            size[par_u] += size[par_v];",
    "        }",
    "    }",
    "};"
  ],
  "description": ""
},
"SegmentTree": {
  "prefix": "SegmentTree",
  "body": [
    "",
    "// segment tree template created by Adnan ahmad.. cf-adnanahmad",
    "function<ll(ll, ll)> F = [](ll a, ll b)",
    "{ return a + b; };",
    "ll Ne = 0LL;",
    "",
    "",
    "struct SegmentTree",
    "{",
    "    ll n;",
    "    vector<ll> tree;",
    "",
    "    SegmentTree(vector<ll> &a)",
    "    {",
    "        n = a.size();",
    "        tree.assign(4 * n, Ne);",
    "        build(a, 1, 0, n - 1);",
    "    }",
    "",
    "    void build(const vector<ll> &a, ll v, ll tl, ll tr)",
    "    {",
    "        if (tl == tr)",
    "        {",
    "            tree[v] = a[tl];",
    "        }",
    "        else",
    "        {",
    "            ll tm = (tl + tr) / 2;",
    "            build(a, v * 2, tl, tm);",
    "            build(a, v * 2 + 1, tm + 1, tr);",
    "            tree[v] = F(tree[v * 2], tree[v * 2 + 1]);",
    "        }",
    "    }",
    "    void upd(ll v, ll tl, ll tr, ll ind, ll val)",
    "    {",
    "        if (tl == tr)",
    "        {",
    "            tree[v] = val;",
    "        }",
    "        else",
    "        {",
    "            ll tm = (tl + tr) / 2;",
    "            if (ind <= tm)",
    "                upd(v * 2, tl, tm, ind, val);",
    "            else",
    "                upd(v * 2 + 1, tm + 1, tr, ind, val);",
    "            tree[v] = F(tree[v * 2], tree[v * 2 + 1]);",
    "        }",
    "    }",
    "",
    "    void upd(ll ind, ll val)",
    "    {",
    "        upd(1, 0, n - 1, ind, val);",
    "    }",
    "",
    "    ll query(ll v, ll tl, ll tr, ll l, ll r)",
    "    {",
    "        if (l > r)",
    "            return Ne;",
    "        if (l == tl && r == tr)",
    "            return tree[v];",
    "        ll tm = (tl + tr) / 2;",
    "        return F(",
    "            query(v * 2, tl, tm, l, min(r, tm)),",
    "            query(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r));",
    "    }",
    "",
    "    ll query(ll l, ll r)",
    "    {",
    "        return query(1, 0, n - 1, l, r);",
    "    }",
    "};",
    ""
  ],
  "description": "segment tree bruh "
}
}
